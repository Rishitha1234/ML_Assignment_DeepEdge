# -*- coding: utf-8 -*-
"""ML_Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NCoIfOSxpt6dDuHS39VvcpdV3wo9jQPM

### **REQUIREMENTS**

Tensorflow    (Version: 2.9.1 )

Numpy         (Version: 1.22.4)

Matplotlib    (Version: 3.5.2)

Scikit-learn  (Version: 1.1.1)

### **INSTALLATION INSTRUCTIONS**
"""

#Run this cell incase you don't have the required libraries
# !pip install numpy
# !pip install tensorflow
# !pip install matplotlib
# !pip install scikit-learn

"""### **DATASET GENERATION**
-- Given the task of predicting the coordinates of a single bright pixel in a 50x50 image, we require a dataset where each image contains exactly one pixel with a value of 255, while all other pixels are set to 0.

--STEPS:
1. Generate Images: Create 50x50 images with a single pixel set to 255, and all others set to 0.
2. Generate Labels: The labels for each image will be the (x, y) coordinates of the bright pixel.
"""

import numpy as np
import random
import matplotlib.pyplot as plt

def generate_dataset(num_samples=10000, img_size=50):
    images = np.zeros((num_samples, img_size, img_size), dtype=np.uint8)
    labels = np.zeros((num_samples, 2), dtype=int)  # Use built-in int

    for i in range(num_samples):
        x = random.randint(0, img_size-1)
        y = random.randint(0, img_size-1)
        images[i, x, y] = 255
        labels[i] = [x, y]

    return images, labels/50

# Generate dataset
images, labels = generate_dataset(num_samples=10000)

# Visualize some samples
fig, axes = plt.subplots(1, 5, figsize=(15, 3))
for i in range(5):
    axes[i].imshow(images[i], cmap='gray')
    axes[i].set_title(f"Label: {labels[i]}")
plt.show()

"""### **MODEL DESIGN**
-- We'll use a Convolutional Neural Network (CNN) to predict the coordinates. The model will take the 50x50 image as input and output two values (x, y).
"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense

def create_model(input_shape=(50, 50, 1)):
    model = Sequential([
        Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),
        MaxPooling2D((2, 2)),
        Conv2D(64, (3, 3), activation='relu'),
        MaxPooling2D((2, 2)),
        Flatten(),
        Dense(128, activation='relu'),
        Dense(2, activation='sigmoid')  # Output layer with 2 neurons for (x, y) coordinates
    ])

    model.compile(optimizer='adam', loss='mse', metrics=['mae'])
    return model

# Create model
model = create_model()
model.summary()

"""### **DATA PREPROCESSING AND TRAINING**"""

# Normalize the images
images = images / 255.0
images = images.reshape(-1, 50, 50, 1)

# Split dataset into training and testing
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(images, labels, test_size=0.2, random_state=42)

# Train the model
history = model.fit(X_train, y_train, epochs=10, validation_split=0.2, batch_size=32)

"""### **EVALUATION AND VISUALIZATION**"""

# Evaluate the model on test data
loss, mse = model.evaluate(X_test, y_test)
print(f"Test Loss: {loss}, Test MSE: {mse}")

# Predict on test data
predictions = model.predict(X_test)

# Compare predictions with ground truth (no visualization of the ground truth dot)
fig, axes = plt.subplots(1, 5, figsize=(15, 3))
for i in range(5):
    axes[i].imshow(X_test[i].reshape(50, 50), cmap='gray')
    # Plot predictions in red
    axes[i].scatter(int(predictions[i][1]*50), int(predictions[i][0]*50), color='red', label='Predicted', s=50, edgecolor='black')
    axes[i].legend()
plt.show()

# Print actual and predicted coordinates for the first 5 test samples
for i in range(5):
    print(f"Sample {i+1}:")
    print(f"  Actual Coordinates: {y_test[i]}")
    print(f"  Predicted Coordinates: {predictions[i]}")